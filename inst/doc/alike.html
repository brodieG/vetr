<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Brodie Gaslam" />


<title>alike</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,%0Abody%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E5%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0A%0Apadding%3A%204px%3B%0Awidth%3A%20100%25%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%201em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Ah3%2Esubtitle%20%7B%0Amargin%2Dtop%3A%20%2D23px%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23EEE%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%0A%7D%0Acode%20%7Bfont%2Dsize%3A%2085%25%3B%7D%0Apre%20%7B%0Aborder%3A%202px%20solid%20%23EEE%3B%0Aoverflow%3A%20auto%3B%0A%0Amargin%3A%205px%200px%3B%0Apadding%3A%205px%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Acolor%3A%20%23353%3B%0A%0A%7D%0Adiv%2EsourceCode%20pre%2C%20div%2EsourceCode%20code%20%7B%0Abackground%2Dcolor%3A%20%23FAFAFA%3B%0A%7D%0Adiv%2EsourceCode%20pre%7B%0A%0A%7D%0Adiv%2EsourceCode%20%2B%20pre%2C%0Adiv%2EsourceCode%20%2B%20div%2Ediffobj%5Fcontainer%20%7B%0Amargin%2Dtop%3A%20%2D5px%3B%0A%7D%0Adiv%2Ediffobj%5Fcontainer%20pre%7B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%2C%20h1%20%3E%20code%2C%20h2%20%3E%20code%2C%20h3%20%3E%20code%2C%0Ah4%20%3E%20code%2C%20h5%20%3E%20code%2C%20h6%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0Aline%2Dheight%3A%201%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Apadding%2Dbottom%3A%203px%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0Aborder%2Dbottom%3A%201px%20solid%20%23999%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23999%3B%0Apadding%2Dtop%3A%205px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Apadding%2Dtop%3A%205px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0A%0Acolor%3A%20%23777%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah4%2Eauthor%20%7Bdisplay%3A%20none%3B%7D%0Ah4%2Edate%20%7Bmargin%2Dtop%3A%20%2D20px%3B%7D%0Ah5%2C%20h6%20%7B%0A%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%232255dd%3B%0Afont%2Dweight%3A%20bold%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23555%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23555%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23555%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">alike</h1>
<h4 class="author"><em>Brodie Gaslam</em></h4>


<div id="TOC">
<ul>
<li><a href="#what-is-alikeness">What is Alikeness?</a></li>
<li><a href="#declarative-comparison">Declarative Comparison</a></li>
<li><a href="#object-comparison">Object Comparison</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#length-comparison">Length Comparison</a></li>
<li><a href="#type-comparison">Type Comparison</a></li>
<li><a href="#recursive-objects">Recursive Objects</a></li>
<li><a href="#language-objects-formulas-and-functions">Language Objects, Formulas, and Functions</a></li>
<li><a href="#s4-and-r5-rc-objects">S4 and R5 (RC Objects)</a></li>
<li><a href="#pointer-objects">Pointer Objects</a></li>
</ul></li>
<li><a href="#attribute-comparison">Attribute Comparison</a><ul>
<li><a href="#normal-attributes">Normal Attributes</a></li>
<li><a href="#special-attributes">Special Attributes</a></li>
</ul></li>
<li><a href="#modifying-comparison-behavior">Modifying Comparison Behavior</a></li>
<li><a href="#creating-templates">Creating Templates</a><ul>
<li><a href="#from-the-ground-up">From The Ground Up</a></li>
<li><a href="#abstracting-existing-structures">Abstracting Existing Structures</a></li>
</ul></li>
<li><a href="#performance-considerations">Performance Considerations</a><ul>
<li><a href="#sample-timings">Sample Timings</a></li>
<li><a href="#pre-defining-templates">Pre-defining Templates</a></li>
</ul></li>
<li><a href="#miscellaneous">Miscellaneous</a><ul>
<li><a href="#alike-as-an-s3-generic"><code>alike</code> as an S3 generic</a></li>
</ul></li>
</ul>
</div>

<div id="what-is-alikeness" class="section level2">
<h2>What is Alikeness?</h2>
<p><code>alike</code> is similar to <code>all.equal</code> from base R except it only compares object structure. As with <code>all.equal</code>, the first argument (<code>target</code>) must be matched by the second (<code>current</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(vetr)
<span class="kw">alike</span>(<span class="kw">integer</span>(<span class="dv">5</span>), <span class="dv">1</span>:<span class="dv">5</span>)      <span class="co"># different values, but same structure</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">integer</span>(<span class="dv">5</span>), <span class="dv">1</span>:<span class="dv">4</span>)      <span class="co"># wrong size</span></code></pre></div>
<pre><code>[1] &quot;`length(1:4)` should be 5 (is 4)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">integer</span>(<span class="dv">26</span>), letters) <span class="co"># same size, but different types</span></code></pre></div>
<pre><code>[1] &quot;`letters` should be type \&quot;integer-like\&quot; (is \&quot;character\&quot;)&quot;</code></pre>
<p><code>alike</code> only compares structural elements that are defined in <code>target</code> (a.k.a. the template). This allows “wildcard” templates. For example, we consider length zero vectors to have undefined length so those match vectors of any length:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">integer</span>(), <span class="dv">1</span>:<span class="dv">5</span>)</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">integer</span>(), <span class="dv">1</span>:<span class="dv">4</span>)</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">integer</span>(), letters)  <span class="co"># type is still defined and must match</span></code></pre></div>
<pre><code>[1] &quot;`letters` should be type \&quot;integer-like\&quot; (is \&quot;character\&quot;)&quot;</code></pre>
<p>Similarly, if a template does not specify an attribute, objects with any value for that attribute will match:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">list</span>(), <span class="kw">data.frame</span>())  <span class="co"># a data frame is a list with a attributes</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">data.frame</span>(), <span class="kw">list</span>())  <span class="co"># but a list does not have the data.frame attributes</span></code></pre></div>
<pre><code>[1] &quot;`list()` should be class \&quot;data.frame\&quot; (is \&quot;list\&quot;)&quot;</code></pre>
<p>As an extension to the wildcard concept, we interpret partially specified <a href="#Special%20Attributes">core R attributes</a>. Here we allow any three column integer matrix to match:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mx.tpl &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">integer</span>(), <span class="dt">ncol=</span><span class="dv">3</span>)          <span class="co"># partially specified matrix</span>
<span class="kw">alike</span>(mx.tpl, <span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">12</span>), <span class="dt">nrow=</span><span class="dv">4</span>))  <span class="co"># any number of rows match</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(mx.tpl, <span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">12</span>), <span class="dt">nrow=</span><span class="dv">3</span>))  <span class="co"># but column count must match</span></code></pre></div>
<pre><code>[1] &quot;`matrix(sample(1:12), nrow = 3)` should have 3 columns (has 4)&quot;</code></pre>
<p>or a data frame of arbitrary number of rows, but same column structure as <code>iris</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iris.tpl &lt;-<span class="st"> </span>iris[<span class="dv">0</span>, ]                        <span class="co"># no rows, but structure is defined</span>
<span class="kw">alike</span>(iris.tpl, iris[<span class="dv">1</span>:<span class="dv">10</span>, ])                <span class="co"># any number of rows match</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(iris.tpl, CO2)                         <span class="co"># but column structure must match</span></code></pre></div>
<pre><code>[1] &quot;`names(CO2)[1]` should be \&quot;Sepal.Length\&quot; (is \&quot;Plant\&quot;)&quot;</code></pre>
<p>“alikeness” is complex to describe, but should be intuitive to grasp. We recommend you look <code>example(alike)</code> to get a sense of “alikeness”. If you want to understand the specifics, read on.</p>
</div>
<div id="declarative-comparison" class="section level2">
<h2>Declarative Comparison</h2>
<p><code>alike</code>’s template based comparison is declarative. You declare what structure an object is expected to implement, and <code>vetr</code> infers all the computations required to verify that is so. This makes is particularly well suited for enforcing structural requirements for S3 objects. The S4 system does this and more, but S3 objects are still used extensively in R code, and sometimes S4 classes are not appropriate.</p>
<p>There are several advantages to template based comparisons:</p>
<ul>
<li>Often times it is simpler to define a template than to write out all the checks to confirm an object conforms to a particular structure.</li>
<li>We can generate the template from a known correct instance of an object and <a href="#Abstracting-Existing-Objects">abstract away</a> the elements that are not specific to the prototype (this is particularly valuable for otherwise complex objects).</li>
<li>We can produce plainish-english interpretations of structural mismatches since we are dealing with a known limited set of comparisons.</li>
</ul>
</div>
<div id="object-comparison" class="section level2">
<h2>Object Comparison</h2>
<div id="overview" class="section level3">
<h3>Overview</h3>
<p><code>alike</code> compares objects on <a href="#type-comparison">type</a>, <a href="#length-comparison">length</a>, and attributes. Recursive structures are compared element by element. <a href="#language-objects">Language objects</a> and <a href="#functions">functions</a> are compared specially because the concept of a value within those is more complex (e.g., is the <code>+</code> in <code>x + y</code> just a value?).</p>
<p>We will defer discussion of attribute comparison to the <a href="#attribute-comparison">attributes section</a>.</p>
</div>
<div id="length-comparison" class="section level3">
<h3>Length Comparison</h3>
<p>Objects must be the same length to be <code>alike</code>, unless the template (<code>target</code>) is zero length, in which case the object may be any length. <a href="#environments">Environments</a> are an exception: we only require that all the elements present in <code>target</code> be present in <code>current</code>. Also, note that calls to <code>(</code> are ignored in <a href="#language-objects">language objects</a>, which may affect length computation.</p>
</div>
<div id="type-comparison" class="section level3">
<h3>Type Comparison</h3>
<p>Type comparison is done on type (i.e. the <code>typeof</code>) with some adjustments to better align comparisons to “percieved” types as opposed to internal storage types.</p>
<div id="numerics-and-integers" class="section level4">
<h4>Numerics and Integers</h4>
<p>We allow integer vectors to be considered numeric, and <a href="#fuzzylen">short</a> integer-like numerics to be treated as integers:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(1L, <span class="dv">1</span>)     <span class="co"># `1` is not technically integer, but we treat it as such</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(1L, <span class="fl">1.1</span>)   <span class="co"># 1.1 is not integer-like</span></code></pre></div>
<pre><code>[1] &quot;`1.1` should be type \&quot;integer-like\&quot; (is \&quot;double\&quot;)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="fl">1.1</span>, 1L)   <span class="co"># integers can match numerics</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>This feature is designed to simplify checks for integer-like numbers. The following two expressions are roughly equivalent:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopifnot</span>(<span class="kw">length</span>(x) ==<span class="st"> </span>1L &amp;&amp;<span class="st"> </span>(<span class="kw">is.integer</span>(x) ||<span class="st"> </span><span class="kw">is.numeric</span>(x) &amp;&amp;<span class="st"> </span><span class="kw">floor</span>(x) ==<span class="st"> </span>x))
<span class="kw">stopifnot</span>(<span class="kw">alike</span>(<span class="kw">integer</span>(1L), x))</code></pre></div>
<p><a name="fuzzylen"></a>Note that we only check numerics of length &lt;= 100 for integerness to avoid full scans on large vectors. We expect that the primary source of these integer-like numerics is hand input vectors (e.g. <code>c(1, 2, 3)</code>), so hopefully this compromise is not too limiting. You can modify the threshold length for this treatment via the <code>fuzzy.int.max.len</code> parameter to the <code>settings</code> objects (see <code>?vetr_settings</code>).</p>
</div>
<div id="functions" class="section level4">
<h4>Functions</h4>
<p>Closures, builtins, and specials are all treated as a single type, even though internally they are stored as different types.</p>
</div>
</div>
<div id="recursive-objects" class="section level3">
<h3>Recursive Objects</h3>
<p><code>alike</code> will recurse through lists (and by extension data frames), pairlists, expressions, and environments and will check pairwise alikeness between the corresponding elements of the <code>target</code> and <code>current</code> objects.</p>
<p><a name="environments"></a>Environments have slightly different comparison rules in two respects:</p>
<ul>
<li>only the elements present in the template are checked, so <code>current</code> may have additional items</li>
<li>if the template is the global environment, then <code>current</code> must be too (this is because the global environment is often littered with many objects, and explicitly comparing it to another environment could be computationally expensive)</li>
</ul>
<p><code>NULL</code> elements within templates in recursive objects are considered undefined and as such act like wildcards:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## two NULLs match two length list
<span class="kw">alike</span>(<span class="kw">list</span>(<span class="ot">NULL</span>, <span class="ot">NULL</span>), <span class="kw">list</span>(<span class="dv">1</span>:<span class="dv">10</span>, letters))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## but not three length list
<span class="kw">alike</span>(<span class="kw">list</span>(<span class="ot">NULL</span>, <span class="ot">NULL</span>), <span class="kw">list</span>(<span class="dv">1</span>:<span class="dv">10</span>, letters, iris))</code></pre></div>
<pre><code>[1] &quot;`length(list(1:10, letters, iris))` should be 2 (is 3)&quot;</code></pre>
<p>Note that top level <code>NULL</code>s do not act as wildcards:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="ot">NULL</span>, <span class="dv">1</span>:<span class="dv">10</span>)                   <span class="co"># NULL only matches NULL</span></code></pre></div>
<pre><code>[1] &quot;`1:10` should be `NULL` (is \&quot;integer\&quot;)&quot;</code></pre>
<p>Treating <code>NULL</code> inconsistently depending on whether it is nested or not is a compromise designed to make <code>alike</code> a better fit for argument validation because arguments that are <code>NULL</code> by default are fairly common.</p>
<p><code>alike</code> will check for self-referential loops in nested environments and prevent infinite recursion. If you somehow introduce a self-referential structure in a template without using environments then <code>alike</code> will get stuck in an infinite recursion loop.</p>
<p>We are currently considering adding new comparison modes for lists that would allow for checks more similar to environments (see <a href="https://github.com/brodieG/vetr/issues/29">#29</a>).</p>
</div>
<div id="language-objects-formulas-and-functions" class="section level3">
<h3>Language Objects, Formulas, and Functions</h3>
<p>Alikeness for these types of objects is a little harder to define. We have settled on somewhat arbitrary semantics, though hopefully they are intuitive. These may change in the future as we gain experience using <code>alike</code> with these types of objects. This is particularly true of functions.</p>
<p>Language objects are also compared recursively, but alikeness has a slightly different meaning for them:</p>
<div id="language-objects" class="section level4">
<h4>Language Objects</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">quote</span>(<span class="kw">sum</span>(a, b)), <span class="kw">quote</span>(<span class="kw">sum</span>(x, y)))   <span class="co"># calls are consistent</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">quote</span>(<span class="kw">sum</span>(a, b)), <span class="kw">quote</span>(<span class="kw">sum</span>(x, x)))   <span class="co"># calls are inconsistent</span></code></pre></div>
<pre><code>[1] &quot;`quote(sum(x, x))[[3]]` should not be `x`&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(a, b)), <span class="kw">quote</span>(<span class="kw">sum</span>(x, y)))  <span class="co"># functions are different</span></code></pre></div>
<pre><code>[1] &quot;`quote(sum(x, y))[[1]]` should be a call to `mean` (is a call to `sum`)&quot;</code></pre>
<p>Since variables can contain anything we do not require them to match directly across calls. In the examples above the second call fails because the template defines different variables for each argument, but the <code>current</code> object uses the same variable twice. The third call fails because the functions are different and as such the calls are fundamentally different.</p>
<p>If a function is defined in the calling frame, <code>alike</code> will <code>match.call</code> it prior to testing alikeness:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fun &lt;-<span class="st"> </span>function(a, b, c) <span class="ot">NULL</span>
<span class="kw">alike</span>(<span class="kw">quote</span>(<span class="kw">fun</span>(p, q, p)), <span class="kw">quote</span>(<span class="kw">fun</span>(y, x, x)))</code></pre></div>
<pre><code>[1] &quot;`quote(fun(y, x, x))[[4]]` should be `y` (is `x`)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># `match.call` re-orders arguments</span>
<span class="kw">alike</span>(<span class="kw">quote</span>(<span class="kw">fun</span>(p, q, p)), <span class="kw">quote</span>(<span class="kw">fun</span>(<span class="dt">b=</span>y, x, x)))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>Constants match any constants, but keep in mind that expressions like <code>1:10</code> or <code>c(1, 2, 3)</code> are calls to <code>:</code> and <code>c</code> respectively, not constants in the context of language objects.</p>
<p><code>NULL</code> is a wild card in calls as well:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(one.arg.tpl &lt;-<span class="st"> </span><span class="kw">as.call</span>(<span class="kw">list</span>(<span class="ot">NULL</span>, <span class="ot">NULL</span>)))</code></pre></div>
<pre><code> language NULL(NULL)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(one.arg.tpl, <span class="kw">quote</span>(<span class="kw">log</span>(<span class="dv">10</span>)))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(one.arg.tpl, <span class="kw">quote</span>(<span class="kw">sd</span>(<span class="kw">runif</span>(<span class="dv">20</span>))))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(one.arg.tpl, <span class="kw">quote</span>(<span class="kw">log</span>(<span class="dv">10</span>, <span class="dv">10</span>)))</code></pre></div>
<pre><code>[1] &quot;`quote(log(10, 10))` should have 1 arguments (has 2)&quot;</code></pre>
<p>Calls to <code>(</code> are ignored when comparing calls since parentheses are redundant in call trees because the tree structure encodes operation precedence independent of operator precedence.</p>
<p>We concede that the rules for “alikeness” of language objects are arbitrary, but hope the outcomes of those rules is generally intuitive. Unfortunately value and structure are somewhat intertwined for language objects so we must impose our own view of what is value and what is structure.</p>
</div>
<div id="formulas" class="section level4">
<h4>Formulas</h4>
<p>Formulas are treated like calls, except that constants must match:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(y ~<span class="st"> </span>x ^<span class="st"> </span><span class="dv">2</span>, a ~<span class="st"> </span>b ^<span class="st"> </span><span class="dv">2</span>)</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(y ~<span class="st"> </span>x ^<span class="st"> </span><span class="dv">2</span>, a ~<span class="st"> </span>b ^<span class="st"> </span><span class="dv">3</span>)</code></pre></div>
<pre><code>[1] &quot;`(a ~ b^3)[[3]][[3]]` should have identical constant values&quot;</code></pre>
</div>
<div id="functions-1" class="section level4">
<h4>Functions</h4>
<p>Functions are <code>alike</code> if the signature of the <code>current</code> function can reasonably be interpreted as a valid method for the <code>target</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(print, print.default)   <span class="co"># print can be the generic for print.default</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(print.default, print)   <span class="co"># but not vice versa</span></code></pre></div>
<pre><code>[1] &quot;`print` should have argument `digits` after argument `x`&quot;</code></pre>
<p>A method of a generic must have all arguments present in the generic, with the same default values if those are defined. If the generic contains <code>...</code> then the method may have additional arguments, but must also contain <code>...</code>.</p>
<p>Potential changes / improvements for function comparison are being considered in <a href="https://github.com/brodieG/vetr/issues/35">#35</a>.</p>
</div>
</div>
<div id="s4-and-r5-rc-objects" class="section level3">
<h3>S4 and R5 (RC Objects)</h3>
<p>S4 and RC objects are considered alike if <code>current</code> inherits from <code>class(target)</code>. Since these objects embed structural information in their definitions <code>alike</code> relies on class alone to establish alikeness.</p>
</div>
<div id="pointer-objects" class="section level3">
<h3>Pointer Objects</h3>
<p>Objects of the following types are actually references to specific memory locations:</p>
<ul>
<li>External Pointers</li>
<li>Weak References</li>
<li>Byte codes</li>
</ul>
<p>These are typically attached as attributes to other objects that contain the information required to establish alikeness (e.g. <code>data.table</code>, byte-compiled functions), so we only check their type.</p>
</div>
</div>
<div id="attribute-comparison" class="section level2">
<h2>Attribute Comparison</h2>
<div id="normal-attributes" class="section level3">
<h3>Normal Attributes</h3>
<p>Much of the structure of an object is determined by attributes. <code>alike</code> recursively compares object attributes and requires them to be <code>alike</code>, unless the attribute is a <a href="#special-attributes">special attribute</a> or an environment. Environments within attributes in the template must be matched by an environment, but nothing is checked about the environments to avoid expensive computations on objects that commonly include environments in their attributes (e.g. formulas); note this is different than the treatment of environments as actual objects.</p>
<p>Only attributes present in the template object are checked:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">structure</span>(<span class="kw">logical</span>(1L), <span class="dt">a=</span><span class="kw">integer</span>(3L)), <span class="kw">structure</span>(<span class="ot">TRUE</span>, <span class="dt">a=</span><span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">b=</span>letters))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">structure</span>(<span class="ot">TRUE</span>, <span class="dt">a=</span><span class="dv">1</span>:<span class="dv">3</span>, <span class="dt">b=</span>letters), <span class="kw">structure</span>(<span class="kw">logical</span>(1L), <span class="dt">a=</span><span class="kw">integer</span>(3L)))</code></pre></div>
<pre><code>[1] &quot;`structure(logical(1L), a = integer(3L))` should have attribute \&quot;b\&quot;&quot;</code></pre>
<p>Attributes present in <code>current</code> but missing in <code>target</code> may be anything at all.</p>
</div>
<div id="special-attributes" class="section level3">
<h3>Special Attributes</h3>
<div id="overview-1" class="section level4">
<h4>Overview</h4>
<p>The special attributes are <code>names</code>, <code>row.names</code>, <code>dim</code>, <code>dimnames</code>, <code>class</code>, <code>tsp</code>, and <code>levels</code>. These attributes are discussed in sections <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Attributes">2.2 and 2.3 of the R Language Definition</a>, and have well defined and consistently applied semantics in R. Since the semantics of these attributes are well known, we are able to define “alikeness” for them in a more granular way than we can for arbitrary attributes.</p>
<p>We also consider <code>srcref</code> to be a special attribute. This attribute is not checked.</p>
</div>
<div id="row.names-and-names" class="section level4">
<h4>row.names and names</h4>
<p>If present in <code>target</code>, then must be matched exactly by the corresponding attribute in <code>current</code>, except that:</p>
<ul>
<li>zero length <code>target</code> <code>names</code>/<code>row.names</code> (i.e. <code>character(0L)</code>) will match any character <code>names</code>/<code>row.names</code></li>
<li>a zero character <em>element</em> (i.e. <code>&quot;&quot;</code>) in a <code>target</code> <code>names</code>/<code>row.names</code> character vector will allow any value to match at the corresponding position of the <code>current</code> <code>names</code>/<code>row.names</code> vector</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">setNames</span>(<span class="kw">integer</span>(), <span class="kw">character</span>()), <span class="dv">1</span>:<span class="dv">3</span>)</code></pre></div>
<pre><code>[1] &quot;`names(1:3)` should be type \&quot;character\&quot; (is \&quot;NULL\&quot;)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">setNames</span>(<span class="kw">integer</span>(), <span class="kw">character</span>()), <span class="kw">c</span>(<span class="dt">a=</span><span class="dv">1</span>, <span class="dt">b=</span><span class="dv">2</span>, <span class="dt">c=</span><span class="dv">3</span>))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">setNames</span>(<span class="kw">integer</span>(<span class="dv">3</span>), <span class="kw">c</span>(<span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;Z&quot;</span>)), <span class="kw">c</span>(<span class="dt">a=</span><span class="dv">1</span>, <span class="dt">b=</span><span class="dv">2</span>, <span class="dt">c=</span><span class="dv">3</span>))</code></pre></div>
<pre><code>[1] &quot;`names(c(a = 1, b = 2, c = 3))[3]` should be \&quot;Z\&quot; (is \&quot;c\&quot;)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(<span class="kw">setNames</span>(<span class="kw">integer</span>(<span class="dv">3</span>), <span class="kw">c</span>(<span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;Z&quot;</span>)), <span class="kw">c</span>(<span class="dt">a=</span><span class="dv">1</span>, <span class="dt">b=</span><span class="dv">2</span>, <span class="dt">Z=</span><span class="dv">3</span>))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
</div>
<div id="dim" class="section level4">
<h4>dim</h4>
<p><code>dim</code> attributes must be identical between <code>target</code> and <code>current</code>, except that if a value of the <code>dim</code> <em>vector</em> is zero in <code>target</code> then the corresponding value in <code>current</code> can be any value. This is how comparisons like the following succeed:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mx.tpl &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">integer</span>(), <span class="dt">ncol=</span><span class="dv">3</span>)                <span class="co"># partially specified matrix</span>
<span class="kw">alike</span>(mx.tpl, <span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">12</span>), <span class="dt">nrow=</span><span class="dv">4</span>))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(mx.tpl, <span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">12</span>), <span class="dt">nrow=</span><span class="dv">3</span>))        <span class="co"># wrong number of columns</span></code></pre></div>
<pre><code>[1] &quot;`matrix(sample(1:12), nrow = 3)` should have 3 columns (has 4)&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(mx.tpl)    <span class="co"># notice 0 for 1st dimension</span></code></pre></div>
<pre><code> int[0 , 1:3] </code></pre>
</div>
<div id="dimnames" class="section level4">
<h4>dimnames</h4>
<p>Must also be identical, except that if the <code>target</code> value of the <code>dimnames</code> list for a particular dimension is <code>NULL</code>, then the corresponding <code>dimnames</code> value in <code>current</code> may be anything. As with <code>names</code>, zero character <code>dimname</code> element elements match any name.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mx.tpl &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">integer</span>(), <span class="dt">ncol=</span><span class="dv">3</span>, <span class="dt">dimnames=</span><span class="kw">list</span>(<span class="dt">row.id=</span><span class="ot">NULL</span>, <span class="kw">c</span>(<span class="st">&quot;R&quot;</span>, <span class="st">&quot;G&quot;</span>, <span class="st">&quot;&quot;</span>)))
mx.cur &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="dv">0</span>:<span class="dv">255</span>, <span class="dv">12</span>), <span class="dt">ncol=</span><span class="dv">3</span>, <span class="dt">dimnames=</span><span class="kw">list</span>(<span class="dt">row.id=</span><span class="dv">1</span>:<span class="dv">4</span>, <span class="dt">rgb=</span><span class="kw">c</span>(<span class="st">&quot;R&quot;</span>, <span class="st">&quot;G&quot;</span>, <span class="st">&quot;Blue&quot;</span>)))
mx.cur2 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">sample</span>(<span class="dv">0</span>:<span class="dv">255</span>, <span class="dv">12</span>), <span class="dt">ncol=</span><span class="dv">3</span>, <span class="dt">dimnames=</span><span class="kw">list</span>(<span class="dv">1</span>:<span class="dv">4</span>, <span class="kw">c</span>(<span class="st">&quot;R&quot;</span>, <span class="st">&quot;G&quot;</span>, <span class="st">&quot;b&quot;</span>)))

<span class="kw">alike</span>(mx.tpl, mx.cur)</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(mx.tpl, mx.cur2)</code></pre></div>
<pre><code>[1] &quot;`names(dimnames(mx.cur2))` should be type \&quot;character\&quot; (is \&quot;NULL\&quot;)&quot;</code></pre>
<p>Note that <code>dimnames</code> can have a <code>names</code> attribute. This <code>names</code> attributed is treated as described in <a href="#row.names-and-names">row.names and names</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(<span class="kw">dimnames</span>(mx.tpl))</code></pre></div>
<pre><code>[1] &quot;row.id&quot; &quot;&quot;      </code></pre>
</div>
<div id="class" class="section level4">
<h4>class</h4>
<p>S3 objects are considered alike if the <code>current</code> class inherits from the <code>target</code> class. Note that “inheritance” here is used in a stricter context than in the typical S3 application:</p>
<ul>
<li>Every class present in <code>target</code> must be present in <code>current</code></li>
<li>The overlapping classes must be in the same order</li>
<li>The last class in <code>current</code> must be the same as the last class in <code>target</code></li>
</ul>
<p>To illustrate:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tpl &lt;-<span class="st"> </span><span class="kw">structure</span>(<span class="ot">TRUE</span>, <span class="dt">class=</span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))
cur &lt;-<span class="st"> </span><span class="kw">structure</span>(<span class="ot">TRUE</span>, <span class="dt">class=</span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))
cur2 &lt;-<span class="st"> </span><span class="kw">structure</span>(<span class="ot">TRUE</span>, <span class="dt">class=</span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;x&quot;</span>))

<span class="kw">alike</span>(tpl, cur)</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(tpl, cur2)</code></pre></div>
<pre><code>[1] &quot;`class(cur2)[2]` should be \&quot;a\&quot; (is \&quot;b\&quot;)&quot;</code></pre>
</div>
<div id="tsp" class="section level4">
<h4>tsp</h4>
<p>The <code>tsp</code> attribute of <code>ts</code> objects behaves similarly to the <a href="#dim"><code>dim</code> attribute</a>. Any component (i.e. start, end, frequency) that is set to zero will act as a wild card. Other components must be identical. It is illegal to set <code>tsp</code> components to zero throught the standard R interface, but you may use <code>abstract</code> as a work-around.</p>
</div>
<div id="levels" class="section level4">
<h4>levels</h4>
<p>Levels are compared like <a href="#row.names-and-names">row.names and names</a>.</p>
</div>
<div id="srcref" class="section level4">
<h4>srcref</h4>
<p>This attribute is completely ignored.</p>
</div>
<div id="normal-attributes-that-happen-to-have-special-names" class="section level4">
<h4>Normal Attributes that Happen To Have Special Names</h4>
<p>If an object contains one of the special attributes, but the attribute value is inconsistent with the standard definition of the attribute, <code>alike</code> will silently treat that attribute as any other normal attribute.</p>
</div>
</div>
</div>
<div id="modifying-comparison-behavior" class="section level2">
<h2>Modifying Comparison Behavior</h2>
<p>You can use the <code>settings</code> parameter to <code>alike</code> to modify comparison behavior. See <code>?vetr_settings</code> for details.</p>
</div>
<div id="creating-templates" class="section level2">
<h2>Creating Templates</h2>
<div id="from-the-ground-up" class="section level3">
<h3>From The Ground Up</h3>
<p>You can always create your own templates by manually building R structures:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">int.scalar &lt;-<span class="st"> </span><span class="kw">integer</span>(1L)
int.mat<span class="fl">.2</span>.by<span class="fl">.4</span> &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">integer</span>(), <span class="dv">2</span>, <span class="dv">4</span>)
<span class="co"># A df without column names</span>
df.chr.num.num &lt;-<span class="st"> </span><span class="kw">structure</span>(
  <span class="kw">list</span>(<span class="kw">character</span>(), <span class="kw">numeric</span>(), <span class="kw">numeric</span>()), <span class="dt">class=</span><span class="st">&quot;data.frame&quot;</span>
)</code></pre></div>
</div>
<div id="abstracting-existing-structures" class="section level3">
<h3>Abstracting Existing Structures</h3>
<p>Alternatively, you can start with a known structure, and abstract away the instance-specific details. For example, suppose we are sending sample collectors out on the field to record information about iris flowers:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iris.tpl &lt;-<span class="st"> </span>iris[<span class="dv">0</span>, ]
<span class="kw">alike</span>(iris.tpl, iris.sample<span class="fl">.1</span>)  <span class="co"># make sure they submit data correctly</span></code></pre></div>
<p>Or equivalently:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iris.tpl &lt;-<span class="st"> </span><span class="kw">abstract</span>(iris)</code></pre></div>
<p><code>abstract</code> is an S3 generic defined by <code>alike</code> along with methods for common objects. <code>abstract</code> primarily sets the <code>length</code> of atomic vectors to zero:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">abstract</span>(<span class="kw">list</span>(<span class="kw">c</span>(<span class="dt">a=</span><span class="dv">1</span>, <span class="dt">b=</span><span class="dv">2</span>, <span class="dt">c=</span><span class="dv">3</span>), letters))</code></pre></div>
<pre><code>[[1]]
named numeric(0)

[[2]]
character(0)</code></pre>
<p>and also abstracts the <code>dim</code>, <code>dimnames</code>, and <code>tsp</code> attributes if present. Other attributes are left untouched unless a specific <code>abstract</code> method exists for a particular object that also modifies attributes. One example of such a method is <code>abstract.lm</code>, and it does some minor tweaking to the base abstractions to allow us to match models produced by <code>lm</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.dummy &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x=</span><span class="kw">runif</span>(<span class="dv">3</span>), <span class="dt">y=</span><span class="kw">runif</span>(<span class="dv">3</span>), <span class="dt">z=</span><span class="kw">runif</span>(<span class="dv">3</span>))
mdl.tpl &lt;-<span class="st"> </span><span class="kw">abstract</span>(<span class="kw">lm</span>(y ~<span class="st"> </span>x +<span class="st"> </span>z, df.dummy))
<span class="co"># TRUE, expecting bi-variate model</span>
<span class="kw">alike</span>(mdl.tpl, <span class="kw">lm</span>(Sepal.Length ~<span class="st"> </span>Sepal.Width +<span class="st"> </span>Petal.Width, iris))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">alike</span>(mdl.tpl, <span class="kw">lm</span>(Sepal.Length ~<span class="st"> </span>Sepal.Width, iris))</code></pre></div>
<pre><code>[1] &quot;`lm(Sepal.Length ~ Sepal.Width, iris)$terms[[3]]` should be a call to `+` (is \&quot;symbol\&quot;)&quot;</code></pre>
<p>The error message is telling us that at index <code>&quot;terms&quot;</code> (i.e. <code>lm(Sepal.Length ~ Sepal.Width, iris)$terms</code>) <code>alike</code> was expecting a call to <code>+</code> instead of a symbol (i.e <code>Sepal.Width + &lt;somevar&gt;</code> instead of <code>Sepal.Width</code>). The message could certainly be more eloquent, but with a little context it should provide enough information to figure out the problem.</p>
</div>
</div>
<div id="performance-considerations" class="section level2">
<h2>Performance Considerations</h2>
<div id="sample-timings" class="section level3">
<h3>Sample Timings</h3>
<p>We have gone to great lengths to make <code>alike</code> fast so that it can be included in other functions without concerns for what overhead:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">type_and_len &lt;-<span class="st"> </span>function(a, b)
  <span class="kw">typeof</span>(a) ==<span class="st"> </span><span class="kw">typeof</span>(b) &amp;&amp;<span class="st"> </span><span class="kw">length</span>(a) ==<span class="st"> </span><span class="kw">length</span>(b)  <span class="co"># for reference</span>

<span class="kw">bench_mark</span>(<span class="dt">times=</span><span class="fl">1e4</span>,
  <span class="kw">identical</span>(rivers, rivers),
  <span class="kw">alike</span>(rivers, rivers),
  <span class="kw">type_and_len</span>(rivers, rivers)
)</code></pre></div>
<pre><code>Mean eval time from 10000 iterations, in microseconds:
  identical(rivers, rivers)     ~  0.8
  alike(rivers, rivers)         ~  3.4
  type_and_len(rivers, rivers)  ~  1.8</code></pre>
<p>While <code>alike</code> is slower than <code>identical</code> and the comparable bare bones R function, it is competitive with a bare bones R function that checks types and length. As objects grow more complex, <code>identical</code> will obviously pull ahead, though <code>alike</code> should be sufficiently fast for most applications:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bench_mark</span>(<span class="dt">times=</span><span class="fl">1e4</span>,
  <span class="kw">identical</span>(mtcars, mtcars),
  <span class="kw">alike</span>(mtcars, mtcars)
)</code></pre></div>
<pre><code>Mean eval time from 10000 iterations, in microseconds:
  identical(mtcars, mtcars)  ~   0.65
  alike(mtcars, mtcars)      ~  13.85</code></pre>
<p>In the above example, we are comparing the data frames, their attributes, and the 11 columns individually.</p>
<p>Keep in mind that the complexity of the <code>alike</code> comparison is driven by the complexity of the template, not the object we are checking, so we can always manage the expense of the <code>alike</code> evaluation.</p>
<p>Comparisons that succeed will be substantially faster than comparisons that fail as the construction of error messages is non-trivial and we have prioritized optimization in the success case.</p>
<p>Language object comparison is relatively slow. We intend to optimize this some day.</p>
<p>Templates with large numbers of attributes (e.g. &gt; 25) may scale non-linearly. We intend to optimize this some day, though in our experience objects with that many attributes are rare (note having multiple objects each with a handful attributes nested in recursive structures is not a problem).</p>
<p>Large objects will be slower to evaluate. Let us revisit the <code>lm</code> example, though this time we compare our template to itself to ensure that the comparisons succeed for <code>alike</code>, <code>all.equal</code>, and <code>identical</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mdl.tpl &lt;-<span class="st"> </span><span class="kw">abstract</span>(<span class="kw">lm</span>(y ~<span class="st"> </span>x +<span class="st"> </span>z, <span class="kw">data.frame</span>(<span class="dt">x=</span><span class="kw">runif</span>(<span class="dv">3</span>), <span class="dt">y=</span><span class="kw">runif</span>(<span class="dv">3</span>), <span class="dt">z=</span><span class="kw">runif</span>(<span class="dv">3</span>))))
<span class="co"># compare mdl.tpl to itself to ensure success in all three scenarios</span>
<span class="kw">bench_mark</span>(
  <span class="kw">alike</span>(mdl.tpl, mdl.tpl),
  <span class="kw">all.equal</span>(mdl.tpl, mdl.tpl),   <span class="co"># for reference</span>
  <span class="kw">identical</span>(mdl.tpl, mdl.tpl)
)</code></pre></div>
<pre><code>Mean eval time from 1000 iterations, in microseconds:
  alike(mdl.tpl, mdl.tpl)      ~   176
  all.equal(mdl.tpl, mdl.tpl)  ~  1856
  identical(mdl.tpl, mdl.tpl)  ~     2</code></pre>
<p>Even with template as large as <code>lm</code> results (check <code>str(mdl.tpl)</code>) we can evaluate <code>alike</code> thousands of times before the overhead becomes noticeable.</p>
</div>
<div id="pre-defining-templates" class="section level3">
<h3>Pre-defining Templates</h3>
<p>Some fairly innocuous R expressions carry substantial overhead. Consider:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df.tpl &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a=</span><span class="kw">integer</span>(), <span class="dt">b=</span><span class="kw">numeric</span>())
df.cur &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a=</span><span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">b=</span><span class="dv">1</span>:<span class="dv">10</span> +<span class="st"> </span>.<span class="dv">1</span>)

<span class="kw">bench_mark</span>(
  <span class="kw">alike</span>(df.tpl, df.cur),
  <span class="kw">alike</span>(<span class="kw">data.frame</span>(<span class="kw">integer</span>(), <span class="kw">numeric</span>()), df.cur)
)</code></pre></div>
<pre><code>Mean eval time from 1000 iterations, in microseconds:
  alike(df.tpl, df.cur)                     ~    8
  alike(data.frame(integer(), numeric())..  ~  395</code></pre>
<p><code>data.frame</code> is a particularly slow constructor, but in general you are best served by defining your templates (including calls to <code>abstract</code>) outside of your function so they are created on package load rather than every time your function is called.</p>
</div>
</div>
<div id="miscellaneous" class="section level2">
<h2>Miscellaneous</h2>
<div id="alike-as-an-s3-generic" class="section level3">
<h3><code>alike</code> as an S3 generic</h3>
<p><code>alike</code> is not currently an S3 generic, but will likely one in the future provided we can create an implementation with and acceptable performance profile.</p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
